
# ==========================================================
# NGINX Configuration for Dockerized Node.js Load Balancer
# ==========================================================
#
# Overview:
# This configuration sets up NGINX as a reverse proxy and load balancer
# for multiple Node.js application containers.
#
# 1. worker_processes:
#    - Number of NGINX worker processes.
#    - More workers allow handling more concurrent requests.
#    - In production, set to the number of CPU cores.
#    - 'auto' lets NGINX detect available CPU cores automatically.
#
# 2. worker_connections:
#    - Maximum number of simultaneous connections per worker process.
#    - Total connections ≈ worker_processes * worker_connections.
#      Example: 1 worker × 1024 connections = 1024 concurrent clients
#               4 workers × 1024 connections = 4096 concurrent clients
#    - Memory impact increases with higher numbers.
#    - NGINX uses an event-driven architecture to handle many connections efficiently.
#
# 3. Upstream:
#    - Defines backend servers that receive traffic from NGINX.
#    - Here, app1, app2, and app3 are Node.js containers.
#    - NGINX can load balance requests using round-robin (default), least connections, or IP hash.
#    - it will forward to the backend which has least number of active connections
#    - https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/
#
# 4. Downstream:
#    - Clients making requests to NGINX (browsers, APIs, etc.).
#
# 5. Reverse Proxy:
#    - NGINX forwards incoming requests to the upstream backend using proxy_pass.
#    - Proxy headers ensure backend apps see original client info:
#      - Host: original host header
#      - X-Real-IP: real client IP
#      - X-Forwarded-For: chain of client IPs
#      - X-Forwarded-Proto: original protocol (HTTP/HTTPS)
#
# 6. Logging:
#    - Access logs are enabled to track which upstream handled each request.
#    - The log format includes client IP, request, status, bytes sent, and upstream server.
#    - Example log entry:
#        127.0.0.1 - - [time] "GET /" 200 1024 upstream: app2:3000
#
# ==========================================================

worker_processes 1;

events {
    worker_connections 1024;
}

http {
    include mime.types;

    # ------------------------
    # Access log configuration
    # ------------------------
    log_format main '$remote_addr - $remote_user xxx[$time_local]xxx '
                '"$request" $status $body_bytes_sent '
                '"$http_referer" "$http_user_agent"';
    access_log /var/log/nginx/access.log main;

    # ------------------------
    # Upstream servers (Node.js backends)
    # ------------------------
    upstream nodejs_cluster {
        
        least_conn;
        #ip_hash;
        server app1:3000 weight=5;
        server app2:3000 weight=1;
        server app3:3000 weight=1;
    }

    # ------------------------
    # Server block
    # ------------------------
    server {
        #listen 80;
        listen 443 ssl;  # Listen on port 443 for HTTPS
        server_name localhost;
        # SSL certificate settings
        ssl_certificate /etc/nginx/certs/nginx-selfsigned.crt;
        ssl_certificate_key /etc/nginx/certs/nginx.selfsigned.key;

        location / {
            proxy_pass http://nodejs_cluster;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }


    # Optional server block for HTTP to HTTPS redirection
    server {
        listen 8080;  # Listen on port 80 for HTTP
        server_name localhost;

        # Redirect all HTTP traffic to HTTPS
        location / {
            return 301 https://$host$request_uri;
        }
    }

}
